# context-insensitive pointer analysis with call graph construction
# name=pa-dlog

.include "T.dom"
.include "F.dom"
.include "M.dom"
.include "I.dom"
.include "H.dom"
.include "V.dom"
.include "Z.dom"

.bddvarorder F0_I0xM0xM1_T0_V0xV1_T1_H0_H1_Z0

###
# Input/Output Relations
###

VHfilter(v:V0,h:H0) input
HT(h:H0,t:T1) input
cha(n:M1,t:T1,m:M0) input
sub(t1:T1,t2:T0) input
MmethArg(m:M0,n:Z0,v:V0) input
MmethRet(m:M0,n:Z0,v:V1) input
IinvkArg(i:I0,n:Z0,v:V1) input
IinvkRet(i:I0,n:Z0,v:V0) input
MI(m:M0,i:I0) input
statIM(i:I0,m:M0) input
specIM(i:I0,m:M0) input
virtIM(i:I0,m:M0) input
MobjValAsgnInst(m:M0,l:V0,h:H0) input
MobjVarAsgnInst(m:M0,l:V0,r:V1) input
MgetInstFldInst(m:M0,l:V0,f:F0,b:V1) input
MputInstFldInst(m:M0,b:V0,f:F0,r:V1) input
MgetStatFldInst(m:M0,l:V0,f:F0) input
MputStatFldInst(m:M0,f:F0,r:V0) input
clinitM(m:M0) input


VH(v:V0,h:H0) output
FH(f:F0,h:H0) output
HFH(h1:H0,f:F0,h2:H1) output
IM(i:I0,m:M0) output

###
# Intermediate Relations
###


# cs265: declare any relations here that you want to store
# intermediate results.  Qualify them as output relations
# (just as VH, FH, HFH, and IM above) so that you can debug
# their contents.  Alternatively, you can leave them
# unqualified.

###
# Constraints
###


IM(i,m) :- statIM(i,m).
IM(i,m) :- specIM(i,m).
#IM(i,m) :- virtIM(i,m).
IM(i,m) :- virtIM(i,m1), cha(m1, t, m), IinvkArg(i, 0, v), VH(v,h), HT(h,t).

#invkMethods(i:I0, m:M0)
#invkMethods(i,m) :- statIM(i,m).
#invkMethods(i,m) :- specIM(i,m).
#invkMethods(i,m) :- virtIM(i,m1), cha(m1, t, m), IinvkArg(i, 0, v), VH(v,h), HT(h,t).

calledMethods(m:M0)
reachableI(i:I0)

calledMethods(0).
calledMethods(m) :- reachableI(i), IM(i,m).

#calledMethods(m) :- clinitM(m).
#calledMethods(m1) :- calledMethods(m2), MI(m2,i), IM(i,m1).
#calledMethods(m1) :- calledMethods(m2), MI(m2,i), invkMethods(i,m1).

#calledMethods(m) :- clinit(m), calledMethods(m1), MobjValAsgnInst(m1, v, h), VH(v,h), HT(h,t), TM(t, m) . 


reachableI(i) :- calledMethods(m), MI(m,i).

FH(f,h) :- calledMethods(m), MputStatFldInst(m, f, v), VH(v,h).

# 1) v = new h
VH(v,h) :- calledMethods(m), MobjValAsgnInst(m, v, h), VHfilter(v,h). 

# 2) v = v1
VH(v,h) :- calledMethods(m), MobjVarAsgnInst(m, v, v1), VH(v1, h), VHfilter(v,h).

# 3) v = b.f, b.f = v1 
VH(v,h) :- calledMethods(m), MgetInstFldInst(m, v, f, b), calledMethods(m1), MputInstFldInst(m1, b, f, v1), VH(v1, h), VHfilter(v,h).

# 6) v = b.f where f is static
VH(v,h) :- calledMethods(m), MgetStatFldInst(m, v, f), calledMethods(m1), MputStatFldInst(m1, f, v1), VH(v1,h), VHfilter(v,h).

# 7) return statement
# input arguments v = va
#VH(v,h) :- calledMethods(m), MI(m,i), IinvkArg(i,n,va), invkMethods(i,m2), MmethArg(m2, n, v), VH(va, h).
VH(v,h) :- reachableI(i), IinvkArg(i,n,va), IM(i,m2), MmethArg(m2, n, v), VH(va, h).

# return arguments vr = v
#VH(vr,h) :- calledMethods(m), MI(m,i), IinvkRet(i,n, vr), invkMethods(i,m2), MmethRet(m2, n, v), VH(v, h).
VH(vr,h) :- reachableI(i), IinvkRet(i,n, vr), IM(i,m2), MmethRet(m2, n, v), VH(v, h).

# cs265: write Datalog rules here specifying how to compute
# output relations from the input relations

HFH(h1, f, h2) :- VH(v1, h1), VH(v2, h2), calledMethods(m), MputInstFldInst(m, v1, f, v2).
#HFH(0, 0, 0).
